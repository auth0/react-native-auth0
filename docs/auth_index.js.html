<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>auth/index.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link
      type="text/css"
      rel="stylesheet"
      href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css"
    />
    <link
      type="text/css"
      rel="stylesheet"
      href="styles/prettify-tomorrow.css"
    />
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css" />
  </head>
  <body>
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger" class="navicon-button x">
      <div class="navicon"></div>
    </label>

    <label for="nav-trigger" class="overlay"></label>

    <nav>
      <li class="nav-link nav-home-link"><a href="index.html">Home</a></li>
      <li class="nav-heading">Classes</li>
      <li class="nav-heading">
        <span class="nav-item-type type-class">C</span
        ><span class="nav-item-name"><a href="Auth.html">Auth</a></span>
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#authorizeUrl">authorizeUrl</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#createUser">createUser</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#exchange">exchange</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#exchangeNativeSocial"
            >exchangeNativeSocial</a
          ></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#loginWithEmail">loginWithEmail</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#loginWithOOB">loginWithOOB</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#loginWithOTP">loginWithOTP</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#loginWithRecoveryCode"
            >loginWithRecoveryCode</a
          ></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#loginWithSMS">loginWithSMS</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#logoutUrl">logoutUrl</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#multifactorChallenge"
            >multifactorChallenge</a
          ></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#passwordlessWithEmail"
            >passwordlessWithEmail</a
          ></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#passwordlessWithSMS">passwordlessWithSMS</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#passwordRealm">passwordRealm</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#refreshToken">refreshToken</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#resetPassword">resetPassword</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#revoke">revoke</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Auth.html#userInfo">userInfo</a></span
        >
      </li>
      <li class="nav-heading">
        <span class="nav-item-type type-class">C</span
        ><span class="nav-item-name"><a href="Auth0.html">Auth0</a></span>
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"><a href="Auth0.html#users">users</a></span>
      </li>
      <li class="nav-heading">
        <span class="nav-item-type type-class">C</span
        ><span class="nav-item-name"
          ><a href="CredentialsManager.html">CredentialsManager</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="CredentialsManager.html#clearCredentials"
            >clearCredentials</a
          ></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="CredentialsManager.html#getCredentials"
            >getCredentials</a
          ></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="CredentialsManager.html#hasValidCredentials"
            >hasValidCredentials</a
          ></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="CredentialsManager.html#requireLocalAuthentication"
            >requireLocalAuthentication</a
          ></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="CredentialsManager.html#saveCredentials"
            >saveCredentials</a
          ></span
        >
      </li>
      <li class="nav-heading">
        <span class="nav-item-type type-class">C</span
        ><span class="nav-item-name"><a href="Users.html">Users</a></span>
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Users.html#.getUser">getUser</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="Users.html#.patchUser">patchUser</a></span
        >
      </li>
      <li class="nav-heading">
        <span class="nav-item-type type-class">C</span
        ><span class="nav-item-name"><a href="WebAuth.html">WebAuth</a></span>
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="WebAuth.html#authorize">authorize</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="WebAuth.html#clearSession">clearSession</a></span
        >
      </li>
      <li class="nav-heading"><a href="global.html">Globals</a></li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="global.html#Auth0Provider">Auth0Provider</a></span
        >
      </li>
      <li class="nav-item">
        <span class="nav-item-type type-function">F</span
        ><span class="nav-item-name"
          ><a href="global.html#useAuth0">useAuth0</a></span
        >
      </li>
    </nav>

    <div id="main">
      <h1 class="page-title">auth/index.js</h1>

      <section>
        <article>
          <pre
            class="prettyprint source linenums"
          ><code>import Client from '../networking';
import {apply} from '../utils/whitelist';
import {toCamelCase} from '../utils/camel';
import AuthError from './authError';
import Auth0Error from './auth0Error';

function responseHandler(response, exceptions = {}) {
  if (response.ok &amp;&amp; response.json) {
    return toCamelCase(response.json, exceptions);
  }
  throw new AuthError(response);
}

/**
 * Auth0 Auth API
 *
 * @see https://auth0.com/docs/api/authentication
 */
class Auth {
  constructor(options = {}) {
    this.client = new Client(options);
    const {clientId} = options;
    if (!clientId) {
      throw new Error('Missing clientId in parameters');
    }
    this.domain = this.client.domain;
    this.clientId = clientId;
  }

  /**
   * Builds the full authorize endpoint url in the Authorization Server (AS) with given parameters.
   *
   * @param {Object} parameters parameters to send to `/authorize`
   * @param {String} parameters.responseType type of the response to get from `/authorize`.
   * @param {String} parameters.redirectUri where the AS will redirect back after success or failure.
   * @param {String} parameters.state random string to prevent CSRF attacks.
   * @returns {String} authorize url with specified parameters to redirect to for AuthZ/AuthN.
   * @see https://auth0.com/docs/api/authentication#authorize-client
   */
  authorizeUrl(parameters = {}) {
    const query = apply(
      {
        parameters: {
          redirectUri: {required: true, toName: 'redirect_uri'},
          responseType: {required: true, toName: 'response_type'},
          state: {required: true},
        },
        whitelist: false,
      },
      parameters,
    );
    return this.client.url(
      '/authorize',
      {...query, client_id: this.clientId},
      true,
    );
  }

  /**
   * Builds the full logout endpoint url in the Authorization Server (AS) with given parameters.
   *
   * @param {Object} parameters parameters to send to `/v2/logout`
   * @param {Boolean} [parameters.federated] if the logout should include removing session for federated IdP.
   * @param {String} [parameters.clientId] client identifier of the one requesting the logout
   * @param {String} [parameters.returnTo] url where the user is redirected to after logout. It must be declared in you Auth0 Dashboard
   * @returns {String} logout url with specified parameters
   * @see https://auth0.com/docs/api/authentication#logout
   */
  logoutUrl(parameters = {}) {
    const query = apply(
      {
        parameters: {
          federated: {required: false},
          clientId: {required: false, toName: 'client_id'},
          returnTo: {required: false},
        },
      },
      parameters,
    );
    return this.client.url('/v2/logout', {...query}, true);
  }

  /**
   * Exchanges a code obtained via `/authorize` (w/PKCE) for the user's tokens
   *
   * @param {Object} parameters parameters used to obtain tokens from a code
   * @param {String} parameters.code code returned by `/authorize`.
   * @param {String} parameters.redirectUri original redirectUri used when calling `/authorize`.
   * @param {String} parameters.verifier value used to generate the code challenge sent to `/authorize`.
   * @returns {Promise}
   * @see https://auth0.com/docs/api-auth/grant/authorization-code-pkce
   */
  exchange(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          code: {required: true},
          verifier: {required: true, toName: 'code_verifier'},
          redirectUri: {required: true, toName: 'redirect_uri'},
        },
      },
      parameters,
    );
    return this.client
      .post('/oauth/token', {
        ...payload,
        client_id: this.clientId,
        grant_type: 'authorization_code',
      })
      .then(responseHandler);
  }

  /**
   * Exchanges an external token obtained via a native social authentication solution for the user's tokens
   *
   * @param {Object} parameters parameters used to obtain user tokens from an external provider's token
   * @param {String} parameters.subjectToken token returned by the native social authentication solution
   * @param {String} parameters.subjectTokenType identifier that indicates the native social authentication solution
   * @param {Object} [parameters.userProfile] additional profile attributes to set or override, only on select native social authentication solutions
   * @param {String} [parameters.audience] API audience to request
   * @param {String} [parameters.scope] scopes requested for the issued tokens. e.g. `openid profile`
   * @returns {Promise}
   *
   * @see https://auth0.com/docs/api/authentication#token-exchange-for-native-social
   */
  exchangeNativeSocial(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          subjectToken: {required: true, toName: 'subject_token'},
          subjectTokenType: {required: true, toName: 'subject_token_type'},
          userProfile: {required: false, toName: 'user_profile'},
          audience: {required: false},
          scope: {required: false},
        },
      },
      parameters,
    );
    return this.client
      .post('/oauth/token', {
        ...payload,
        client_id: this.clientId,
        grant_type: 'urn:ietf:params:oauth:grant-type:token-exchange',
      })
      .then(responseHandler);
  }

  /**
   * Performs Auth with user credentials using the Password Realm Grant
   *
   * @param {Object} parameters password realm parameters
   * @param {String} parameters.username user's username or email
   * @param {String} parameters.password user's password
   * @param {String} parameters.realm name of the Realm where to Auth (or connection name)
   * @param {String} [parameters.audience] identifier of Resource Server (RS) to be included as audience (aud claim) of the issued access token
   * @param {String} [parameters.scope] scopes requested for the issued tokens. e.g. `openid profile`
   * @returns {Promise}
   * @see https://auth0.com/docs/api-auth/grant/password#realm-support
   */
  passwordRealm(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          username: {required: true},
          password: {required: true},
          realm: {required: true},
          audience: {required: false},
          scope: {required: false},
        },
        whitelist: false,
      },
      parameters,
    );
    return this.client
      .post('/oauth/token', {
        ...payload,
        client_id: this.clientId,
        grant_type: 'http://auth0.com/oauth/grant-type/password-realm',
      })
      .then(responseHandler);
  }

  /**
   * Obtain new tokens using the Refresh Token obtained during Auth (requesting `offline_access` scope)
   *
   * @param {Object} parameters refresh token parameters
   * @param {String} parameters.refreshToken user's issued refresh token
   * @param {String} [parameters.scope] scopes requested for the issued tokens. e.g. `openid profile`
   * @returns {Promise}
   * @see https://auth0.com/docs/tokens/refresh-token/current#use-a-refresh-token
   */
  refreshToken(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          refreshToken: {required: true, toName: 'refresh_token'},
          scope: {required: false},
        },
        whitelist: false,
      },
      parameters,
    );
    return this.client
      .post('/oauth/token', {
        ...payload,
        client_id: this.clientId,
        grant_type: 'refresh_token',
      })
      .then(responseHandler);
  }

  /**
   * Starts the Passworldess flow with an email connection
   *
   * @param {Object} parameters passwordless parameters
   * @param {String} parameters.email the email to send the link/code to
   * @param {String} parameters.send the passwordless strategy, either 'link' or 'code'
   * @param {String} parameters.authParams optional parameters, used when strategy is 'linḱ'
   * @returns {Promise}
   */
  passwordlessWithEmail(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          email: {required: true},
          send: {required: false},
          authParams: {required: false},
        },
        whitelist: false,
      },
      parameters,
    );
    return this.client
      .post('/passwordless/start', {
        ...payload,
        connection: 'email',
        client_id: this.clientId,
      })
      .then(responseHandler);
  }

  /**
   * Starts the Passworldess flow with an SMS connection
   *
   * @param {Object} parameters passwordless parameters
   * @param {String} parameters.phoneNumber the phone number to send the link/code to
   * @returns {Promise}
   */
  passwordlessWithSMS(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          phoneNumber: {required: true, toName: 'phone_number'},
          send: {required: false},
          authParams: {required: false},
        },
        whitelist: false,
      },
      parameters,
    );
    return this.client
      .post('/passwordless/start', {
        ...payload,
        connection: 'sms',
        client_id: this.clientId,
      })
      .then(responseHandler);
  }

  /**
   * Finishes the Passworldess authentication with an email connection
   *
   * @param {Object} parameters passwordless parameters
   * @param {String} parameters.email the email where the link/code was received
   * @param {String} parameters.code the code numeric value (OTP)
   * @param {String} parameters.audience optional API audience to request
   * @param {String} parameters.scope optional scopes to request
   * @returns {Promise}
   */
  loginWithEmail(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          email: {required: true, toName: 'username'},
          code: {required: true, toName: 'otp'},
          audience: {required: false},
          scope: {required: false},
        },
        whitelist: false,
      },
      parameters,
    );
    return this.client
      .post('/oauth/token', {
        ...payload,
        client_id: this.clientId,
        realm: 'email',
        grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp',
      })
      .then(responseHandler);
  }

  /**
   * Finishes the Passworldess authentication with an SMS connection
   *
   * @param {Object} parameters passwordless parameters
   * @param {String} parameters.phoneNumber the phone number where the code was received
   * @param {String} parameters.code the code numeric value (OTP)
   * @param {String} parameters.audience optional API audience to request
   * @param {String} parameters.scope optional scopes to request
   * @returns {Promise}
   */
  loginWithSMS(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          phoneNumber: {required: true, toName: 'username'},
          code: {required: true, toName: 'otp'},
          audience: {required: false},
          scope: {required: false},
        },
        whitelist: false,
      },
      parameters,
    );
    return this.client
      .post('/oauth/token', {
        ...payload,
        client_id: this.clientId,
        realm: 'sms',
        grant_type: 'http://auth0.com/oauth/grant-type/passwordless/otp',
      })
      .then(responseHandler);
  }

  /**
   * Log in a user using the One Time Password code after they have received the 'mfa_required' error.
   * The MFA token tells the server the username or email, password, and realm values sent on the first request.
   *
   * Requires your client to have the **MFA OTP** Grant Type enabled.
   * See [Client Grant Types](https://auth0.com/docs/clients/client-grant-types) to learn how to enable it.
   *
   * @param {Object} parameters login with OTP parameters
   * @param {String} parameters.mfaToken the token received in the previous login response
   * @param {String} parameters.otp the one time password code provided by the resource owner, typically obtained from an MFA application such as Google Authenticator or Guardian.
   * @returns {Promise}
   */
  loginWithOTP(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          mfaToken: {required: true, toName: 'mfa_token'},
          otp: {required: true, toName: 'otp'},
        },
        whitelist: false,
      },
      parameters,
    );
    return this.client
      .post('/oauth/token', {
        ...payload,
        client_id: this.clientId,
        grant_type: 'http://auth0.com/oauth/grant-type/mfa-otp',
      })
      .then(responseHandler);
  }

  /**
   * Log in a user using an Out Of Band authentication code after they have received the 'mfa_required' error.
   * The MFA token tells the server the username or email, password, and realm values sent on the first request.
   *
   * Requires your client to have the **MFA OOB** Grant Type enabled. See [Client Grant Types](https://auth0.com/docs/clients/client-grant-types) to learn how to enable it.
   *
   * @param {Object} parameters login with Recovery Code parameters
   * @param {String} parameters.mfaToken the token received in the previous login response
   * @param {String} parameters.oobCode the out of band code received in the challenge response.
   * @param {String} parameters.bindingCode [Optional] the code used to bind the side channel (used to deliver the challenge) with the main channel you are using to authenticate. This is usually an OTP-like code delivered as part of the challenge message.
   *
   * @returns {Promise}
   */

  loginWithOOB(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          mfaToken: {required: true, toName: 'mfa_token'},
          oobCode: {required: true, toName: 'oob_code'},
          bindingCode: {required: false, toName: 'binding_code'},
        },
        whitelist: false,
      },
      parameters,
    );

    return this.client
      .post('/oauth/token', {
        ...payload,
        client_id: this.clientId,
        grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',
      })
      .then(responseHandler);
  }

  /**
   * Log in a user using a multi-factor authentication Recovery Code after they have received the 'mfa_required' error.
   * The MFA token tells the server the username or email, password, and realm values sent on the first request.
   *
   * Requires your client to have the **MFA** Grant Type enabled. See [Client Grant Types](https://auth0.com/docs/clients/client-grant-types) to learn how to enable it.
   *
   * @param {Object} parameters login with Recovery Code parameters
   * @param {String} parameters.mfaToken the token received in the previous login response
   * @param {String} parameters.recoveryCode the recovery code provided by the end-user.
   * @returns {Promise}
   */
  loginWithRecoveryCode(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          mfaToken: {required: true, toName: 'mfa_token'},
          recoveryCode: {required: true, toName: 'recovery_code'},
        },
        whitelist: false,
      },
      parameters,
    );

    return this.client
      .post('/oauth/token', {
        ...payload,
        client_id: this.clientId,
        grant_type: 'http://auth0.com/oauth/grant-type/mfa-recovery-code',
      })
      .then(responseHandler);
  }

  /**
   * Request a challenge for multi-factor authentication (MFA) based on the challenge types supported by the application and user.
   * The challenge type is how the user will get the challenge and prove possession. Supported challenge types include: "otp" and "oob".
   *
   * @param {Object} parameters challenge request parameters
   * @param {String} parameters.mfaToken the token received in the previous login response
   * @param {String} parameters.challengeType A whitespace-separated list of the challenges types accepted by your application.
   * Accepted challenge types are oob or otp. Excluding this parameter means that your client application
   * accepts all supported challenge types.
   * @param {String} parameters.authenticatorId The ID of the authenticator to challenge.
   * @returns {Promise}
   */
  multifactorChallenge(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          mfaToken: {required: true, toName: 'mfa_token'},
          challengeType: {required: false, toName: 'challenge_type'},
          authenticatorId: {required: false, toName: 'authenticator_id'},
        },
      },
      parameters,
    );
    return this.client
      .post('/mfa/challenge', {
        ...payload,
        client_id: this.clientId,
      })
      .then(responseHandler);
  }

  /**
   * Revoke an issued refresh token
   *
   * @param {Object} parameters revoke token parameters
   * @param {String} parameters.refreshToken user's issued refresh token
   * @returns {Promise}
   */
  revoke(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          refreshToken: {required: true, toName: 'token'},
        },
      },
      parameters,
    );
    return this.client
      .post('/oauth/revoke', {
        ...payload,
        client_id: this.clientId,
      })
      .then(response => {
        if (response.ok) {
          return {};
        }
        throw new AuthError(response);
      });
  }

  /**
   * Return user information using an access token
   *
   * @param {Object} parameters user info parameters
   * @param {String} parameters.token user's access token
   * @returns {Promise}
   */
  userInfo(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          token: {required: true},
        },
      },
      parameters,
    );
    const {baseUrl, telemetry} = this.client;
    const client = new Client({baseUrl, telemetry, token: payload.token});
    const claims = [
      'sub',
      'name',
      'given_name',
      'family_name',
      'middle_name',
      'nickname',
      'preferred_username',
      'profile',
      'picture',
      'website',
      'email',
      'email_verified',
      'gender',
      'birthdate',
      'zoneinfo',
      'locale',
      'phone_number',
      'phone_number_verified',
      'address',
      'updated_at',
    ];
    return client
      .get('/userinfo')
      .then(response =>
        responseHandler(response, {attributes: claims, whitelist: true}),
      );
  }

  /**
   * Request an email with instructions to change password of a user
   *
   * @param {Object} parameters reset password parameters
   * @param {String} parameters.email user's email
   * @param {String} parameters.connection name of the connection of the user
   * @returns {Promise}
   */
  resetPassword(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          email: {required: true},
          connection: {required: true},
        },
      },
      parameters,
    );
    return this.client
      .post('/dbconnections/change_password', {
        ...payload,
        client_id: this.clientId,
      })
      .then(response => {
        if (response.ok) {
          return {};
        }
        throw new AuthError(response);
      });
  }

  /**
   *
   *
   * @param {Object} parameters create user parameters
   * @param {String} parameters.email user's email
   * @param {String} parameters.password user's password
   * @param {String} parameters.connection name of the database connection where to create the user
   * @param {String} [parameters.username] user's username
   * @param {String} [parameters.give_name] The user's given name(s)
   * @param {String} [parameters.family_name] The user's family name(s)
   * @param {String} [parameters.name] The user's full name
   * @param {String} [parameters.nickname] The user's nickname
   * @param {String} [parameters.picture] A URI pointing to the user's picture
   * @param {String} [parameters.metadata] additional user information that will be stored in `user_metadata`
   * @returns {Promise}
   */
  createUser(parameters = {}) {
    const payload = apply(
      {
        parameters: {
          email: {required: true},
          password: {required: true},
          connection: {required: true},
          username: {required: false},
          given_name: {required: false},
          family_name: {required: false},
          name: {required: false},
          nickname: {required: false},
          picture: {required: false},
          metadata: {required: false, toName: 'user_metadata'},
        },
      },
      parameters,
    );

    return this.client
      .post('/dbconnections/signup', {
        ...payload,
        client_id: this.clientId,
      })
      .then(response => {
        if (response.ok &amp;&amp; response.json) {
          return toCamelCase(response.json);
        }
        throw new Auth0Error(response);
      });
  }
}

export default Auth;
</code></pre>
        </article>
      </section>
    </div>

    <br class="clear" />

    <footer>
      Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.11</a> on
      Thu Feb 09 2023 09:45:58 GMT+0530 (India Standard Time) using the Minami
      theme.
    </footer>

    <script>
      prettyPrint();
    </script>
    <script src="scripts/linenumber.js"></script>
  </body>
</html>
